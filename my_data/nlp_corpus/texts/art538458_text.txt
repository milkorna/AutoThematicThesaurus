В предыдущей статье я рассказал, как подготовить датасет, содержащий тексты блога habr.com с информацией об их принадлежности к определенной категории. Теперь на базе этого датасета я расскажу о подходах, позволяющих создать классификатор, автоматически относящий текст к той или иной категории.
Сегодня нам предстоит описать решение задачи по созданию классификатора текстовых документов. Шаг за шагом мы будем пытаться улучшить нашу модель. Давайте посмотрим, что же из этого получится.
Для решения нашей задачи снова используем язык программирования python и среду разработки Jupyter notebook на платформе Google Colab.
В работе понадобятся следующие библиотеки:
scikit-learn – свободно распространяемая библиотека на python, содержащая реализации различных методов машинного обучения;
nltk – пакет библиотек для символьной и статистической обработки естественного языка;
matplotlib – библиотека, содержащая набор инструментов для визуализации данных, — понадобится для отображения «облака слов».
Подробности реализации.
Датасет сохранен в файле формата csv и содержит чуть более 8 тысяч записей. Для работы с ним будем использовать библиотеку pandas – загружаем данные в память при помощи метода read_csv и отображаем на экране несколько первых строк:
Набор данных представляет собой таблицу, в первой колонке которой хранится текст статьи, во второй – присвоенная категория (класс):
Построим «облако слов» для набора данных, чтобы визуально определить наиболее часто встречающиеся слова – это позволит оценить необходимость дополнительной очистки текстов от «мусора», не несущего смысловой нагрузки:
Для необработанного набора данных «облако слов» содержит 243024 уникальных слова и выглядит так:
Попробуем очистить данные:
После небольшой очистки текстов от «стоп-слов» и знаков пунктуации количество уникальных слов снизилось до 142253, а «облако слов» стало более осмысленным:
При желании можно очистить тексты еще более качественно (в реальных задачах так и следует делать), но для обучающего примера датасет уже вполне подходит.
Посмотрим статистику по классам:
Видно, что некоторые классы представлены только одним элементом, а класс «Чулан» составляет более 65% датасета. Для того чтобы работать с более или менее сбалансированным датасетом, выберем тексты только четырех классов:
Разделим датасет на тренировочную, тестовую и валидационную части:
Получили следующее соотношение выборок: X_train – 1136 элементов, X_test – 283 элемента, X_valid – 158 элементов.
Для дальнейшей работы понадобится импортировать несколько модулей из библиотеки scikit-learn:
Сначала создадим 2 классификатора (чтобы можно было в дальнейшем сравнить качество получившихся моделей) и обучим их на тестовых данных:
Предскажем получившимися моделями класс текстов в тестовой выборке и сравним метрики:
В связи с тем, что датасет не сбалансирован, метрику «accuracy» (доля верных ответов) использовать нельзя, так как это приведет к завышенной оценке качества работы классификатора. В данном случае самое правильное – считать сразу несколько метрик, устойчивых к распределению классов (в данном случае, это — точность, полнота и f-мера) и смотреть на них все. Однако часто бывает удобно получить не большой набор цифр, а одно число, по которому можно понять, насколько хорошо модель работает. В нашей задаче лучше всего подходит «macro-avg» (сначала подсчитывается каждая метрика по каждому классу, а потом усредняется). Macro-avg более устойчива к скошенным распределениям классов.
Линейный классификатор показал лучший результат на тестовых данных (0,77 против 0,72 у классификатора методом ближайших соседей), поэтому для дальнейшей настройки модели будем использовать его.
На текущий момент классификатор обучен с параметрами по умолчанию. Для большинства задач это вполне приемлемо. Но для более качественной работы модели лучше провести ее дополнительную настройку. В этом случае удобно использовать поиск лучшего сочетания по сетке параметров. Так, можно задать набор значений для параметров классификатора и передать его в модуль GridSearchCV. Он выполнит обучение и оценку модели на каждом сочетании параметров и выдаст лучший результат.
Попробуем улучшить нашу модель, используя различные параметры. Следует иметь в виду, что для доступа к параметрам объекта pipeline необходимо указывать их в виде «название объекта»__«название параметра»:
Обучим модель, используя предложенные параметры (часть из них получила значение по умолчанию, поэтому их указывать не обязательно), и оценим ее качество на тестовых данных:
Значение целевой метрики выросло.
На валидационной выборке качество также выросло (0,8 против 0,76 с использованием стандартных параметров классификатора), следовательно, мы успешно справились с поставленной задачей.
В данной статье я постарался описать решение задачи по созданию классификатора текстовых документов. Здесь представлены только общие шаги, но и они позволили достичь достаточно хорошего результата. Для дальнейшего улучшения модели можно увеличить датасет и провести его дополнительную очистку, попробовать другие классификаторы (например, RandomForestClassifier) и другие сочетания их параметров.
Надеюсь, статья была полезной и поможет вам начать самостоятельно решать nlp-задачи.