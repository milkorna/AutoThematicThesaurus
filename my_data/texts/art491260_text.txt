При решении задач, связанных с распознаванием (Speech-To-Text) и генерацией (Text-To-Speech) речи важно, чтобы транскрипт соответствовал тому, что произнёс говорящий — то есть реально устной речи. Это означает, что прежде чем письменная речь станет нашим транскриптом, её нужно нормализовать.
Другими словами, текст нужно провести через несколько этапов:
Замена числа прописью: 1984 год -> тысяча девятьсот восемьдесят четвёртый год;
Расшифровка сокращений: 2 мин. ненависти -> две минуты ненависти;
Транскрипция латиницы: Orwell -> Оруэлл и т.д.
В этой статье я коротко расскажу о том, как развивалась нормализация в датасете русской речи Open_STT, какие инструменты использовались и о нашем подходе к задаче.
Как вишенка на торте, мы решили выложить наш нормализатор на базе seq2seq в открытый доступ: ссылка на github. Он максимально прост в использовании и вызывается одним методом:
Подробнее про задачу.
Так в чём же, собственно, проблема? Сокращения на то и сокращения, что их можно легко привести к начальной форме. На самом деле, тут всё не так однозначно и без интуиции носителя языка во всех нюансах тяжело разобраться.
Чтобы показать, насколько глубока кроличья нора, приведу несколько примеров с числительными:
2е — второе(ые), но д. 2е — два е;
2 части — две части, но нет 2 части — нет второй части;
длиной до 2 км — длиной до двух километров, но едем до 2 км — едем до второго километра;
= 2/5 — равно две пятых, но д. 2/5 — дом два дробь пять или даже — два пять.
Не меньше проблем с расшифровкой сокращений: одна и та же аббревиатура может читаться по-разному в зависимости от контекста( г — город или год ) и человека( БЦ — б ц или бизнес центр?). Думаю, что творится с транскрипцией других языков, вы уже и сами догадались. Особенно остро проблема стоит с обработкой разговорной речи.
Статистическая модель.
Во всем этом многоообразии легко потеряться и уйти в бесконечный цикл с поиском и обработкой всё новых и новых кейсов. В какой-то момент лучше остановиться и вспомнить о принципе Парето. Вместо того, чтобы решать задачу в общем виде, мы можем обработать ~20% самых частотных случаев, но покрыть ~80% языка.
В первых релизах Open_STT мы подошли к решению ещё брутальней: видим число — заменяем его на дефолтное количественное числительное. С точки зрения STT такое решение было даже оправданным, всё-таки 2020 год лучше превратить в две тысячи двадцать год и ошибиться только в одном символе, чем проигнорировать целых три слова.
Постепенно мы подкрутили ещё контекстозависимость. Теперь числительные перед словом год становились порядковыми и 2020 год наконец превратилось в две тысячи двадцатый. Так появился наш "ручной" статистический пайплайн — находим наиболее популярные комбинации и добавляем их в набор правил.
Sequence to Sequence модели.
В какой-то момент стало понятно, что архитектура sequence-to-sequence (seq2seq) идеально подходит под описание нашей задачи. Действительно, seq2seq умеет делать всё то же самое, что и "ручной" пайплайн, и даже больше:
Преобразует одну последовательность в другую — чек;
Учитывает контекст — чек;
Сам статистически определяет правила, по которым последовательность преобразуется — чек;
В качестве основы мы взяли реализацию модели seq2seq на PyTorch отсюда. Не будем подробно останавливаться на архитектуре — лучше прочитайте исходный пост. На вход подавалась последовательность символов из словаря русских букв + латиница + пунктуация + спец токены, на выходе — только русские буквы + пунктуация.
Очевидный факт — качество модели напрямую зависит от качества данных, на которых она училась. Найти такие данные в достаточном количестве для того же английского языка не составляет труда (более того, гуглятся даже готовые решения с открытым кодом) Но вот с русским пришлось попотеть.
Так, для обучающей выборки мы замиксовали:
Нормализованные данные из открытых источников — Russian Text Normalization;
Отфильтрованные данные со случайных веб-сайтов, прогнанные через наш ручной пайплайн.;
Парочку аугментаций, чтобы сделать сетку более устойчивой к выбросам — пунктуация и пробелы в рандомных местах, капитализация, длинные числа и т.д.
Тестим TorchScript.
Нашей целью было не только решение задачи, но и тест разных интересных вещей, одним из которых стал Torchscript.
TorchScript — это замечательный инструмент из PyTorch, с помощью которого можно выкатить свою модель далеко за рамки Python и даже встроить в C++.
Если коротко, PyTorch даёт нам на выбор два пути:
Хардкорный, с полным погружением в пучину TorchScript языка, со всеми вытекающими последствиями;
Готовый инструмент torch.jit.script (и torch.jit.trace), работающий из коробки.
Как оказалось, для чуть более сложных моделей, чем те, что представлены в гайде, придётся переписать пару строк кода. Однако, тут можно обойтись малой кровью: подумать о типизации, переписать неподдерживаемые функции и т.д. Больше подробностей в посте на канале.
Примеры работы.
Как итог, приведу несколько примеров работы уже готового нормализатора. Все предложения взяты из тестового корпуса, то есть во время тренировки модель с ними не встречалась.
norm.norm_string("Вторая по численности группа — фарсиваны — от 27 до 38 %.").
'Вторая по численности группа — фарсиваны — от двадцати семи до тридцати восьми процентов.'.
norm.norm_string("Висенте Каньяс родился 22 октября 1939 года").
'Висенте Каньяс родился двадцать второго октября тысяча девятьсот тридцать девятого года'.
norm.norm_string("играет песня «The Crying Game»").
'играет песня «зэ краинг гейм»'.
norm.norm_string("к началу XVIII века").
'к началу восемнадцатого века'.
norm.norm_string("и в 2012 году составляла 6,6 шекеля").