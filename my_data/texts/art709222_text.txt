Вышедшая чуть больше месяца назад ChatGPT уже успела нашуметь: школьникам в Нью-Йорке запрещают использовать нейросеть в качестве помощника, её же ответы теперь не принимаются на StackOverflow, а Microsoft планирует интеграцию в поисковик Bing - чем, кстати, безумно обеспокоен СЕО Alphabet (Google) Сундар Пичаи. Настолько обеспокоен, что в своём письме-обращении к сотрудникам объявляет " Code Red " ситуацию. В то же время Сэм Альтман, CEO OpenAI - компании, разработавшей эту модель - заявляет, что полагаться на ответы ChatGPT пока не стоит:
Насколько мы действительно близки к внедрению продвинутых чат-ботов в поисковые системы , как может выглядеть новый интерфейс взаимодействия , и какие основные проблемы есть на пути интеграции? Могут ли модели сёрфить интернет бок о бок с традиционными поисковиками? На эти и многие другие вопросы постараемся ответить под катом.
Данная статья в сущности представляет собой разбор подхода WebGPT (одного из предков ChatGPT ), но с большим количеством сопроводительной и уточняющей информации , а также моих комментариев и мнений . Предполагается, что целевая аудитория не погружена глубоко в технические детали обучения языковых моделей, да и в тему NLP в целом, однако статья будет полезна и экспертам этих областей. Сначала будет дано верхнеуровневое описание ситуации и проблем, а затем - более подробное, обильно снабжённое пояснениями потенциальное решение.
Даже если у вас нет знаний в машинном обучении - эта статья будет полезна и максимально информативна. Все примеры проиллюстрированы и объяснены.
План статьи.
Языковые модели и факты;
А врут ли модели?
Ответы, подкрепленные источниками и фактами;
Базовый принцип обучения WebGPT с учителем;
Шаг обучения WebGPT для продвинутых: готовим данные;
Шаг обучения WebGPT для продвинутых: учим модель учить модель;
Регуляризация при обучении WebGPT;
Альтернатива RL: меняем шило на мыло;
Метрики и восприятие людьми;
Заключение.
Языковые модели и факты.
Языковые модели , или Language Models (LM) , решают очень простую задачу: предсказание следующего слова (или токена , части слова). Через такой простой фреймворк можно решать огромное множество задач: перевод текста, ответы на вопросы, классификация, регрессия (предсказывать слова вроде "3.7" или "0451", если задача сгенерировать вещественное число или код для сейфа), рекомендация, поиск... Даже команды роботам можно давать ! Для обученной языковой модели на вход можно подать текст, а она допишет его, сгенерировав продолжение . Самый простой и понятный пример - клавиатура смартфона, предсказывающая по введеному тексту то, что будет написано дальше.
Если вам хочется глубже и в деталях разобраться в принципах работы LMок, то рекомендую начать вот с этих ссылок: раз , два , три.
Если задуматься, что находится внутри языковой модели, что она выучивает для решения задачи предсказания следующего токена, то условно всё можно разделить на две большие группы: факты/знания реального мира и общеязыковая информация . Ответ на вопрос "В каком году состоялся релиз фильма X?" требует фактической информации, и необходимо быть предельно точным в ответе - ведь ошибка на +-1 год делает ответ неверным. С другой стороны, в предложении "Катя не смогла перейти дорогу, потому что та была мокрой" слово "та" в придаточной части явно относится к объекту "дорога", а не к Кате. Это ясно нам, человекам, и как показывают современные языковые модели - это понятно и им. Но для установления этой связи не нужно знать фактов, только структуру языка.
Проблема в том, что и ту, и другую составляющую модель будет учить одновременно , сохраняя информацию в свои веса (параметры). Отсюда логичный вывод - чем больше модель, тем больше она запоминает (ведь количество общеязыковой информации ограничено). Меморизация может порой удивлять - GPT-3, к примеру, знает точный MD5-hash строки "b", и выводит его по запросу. Но у всего есть пределы, и, к сожалению, в языковых моделях мы пока не научились их определять (хотя работы в этом направлении ведутся ). На текущем этапе их ( или нашего? ) развития невозможно заведомо сказать, знает ли модель что-то , и знает ли она, что она не знает. А главное - как менять факты в ее "голове"? Как их добавлять? Как сделать оценку "количества знаний" (что бы это не значило)? Как контролировать генерацию, не давая модели возможность искажать информацию и откровенно врать?
А врут ли модели?
Именно неспособность ответить на эти вопросы, привела к тому, что демо модели Galactica , недавней разработки компании META, было свернуто . Еще недавно можно было зайти на сайт, вбить какую-то научную идею, а великий AI выдавал целую статью или блок формул по теме . Сейчас он только хранит набор отобранных примеров, ну и ссылку на оригинальную статью. Жила эта модель открыто почти неделю, но, как это часто бывает ( привет от Microsoft), в Твиттере произошел хлопок – и демку закрыли (но веса и код остались доступны). Для справки: это была огромная (120 миллиардов параметров, в GPT-3 175B, то есть это модели одного порядка) языковая модель, натренированная на отфильтрованных статьях и текстах, умеющая работать с LaTeX-формулами, с ДНК-последовательностями, и все это с опорой на научные работы. Причина "провала" очень проста и доступна любому, кто понимает принцип генерации текста LM'ками - модель выдает ссылки на несуществующие статьи, ошибается в фактах (как и практически все языковые модели), и вообще с полной уверенностью заявляет нечто, что человек с экспертизой расценит как несусветный бред (но не сразу, конечно, это еще вчитаться в текст надо).
Занятен тот факт, что Galactica вышла (и умерла) незадолго до ChatGPT , хотя примеров лжи и подтасовки фактов у последней куда больше (особенно с фактической информацией) - как минимум потому, что модель завирусилась. По некоторым причинам популярность ChatGPT взлетела просто до небес в кратчайшие сроки - уже на 5й день количество пользователей превысило миллион!
И несмотря на то, что команда OpenAI проделала хорошую работу по улучшению безопасности модели - заученный ответ "я всего лишь большая языковая модель" на странные вопросы даже стал мемом - нашлись умельцы, которые смогли ее разболтать, заставив нейронку притвориться кем-либо (даже терминалом линукс с собственной файловой системой).
Ответы, подкрепленные источниками и фактами.
Если упростить все вышенаписанное, то получится, что.
Языковые модели врут. Много и бесконтрольно.
Настолько много, что META решает отключить свою модель, а люди в Twitter высказывают недовольство подлогом фактов и нерелевантными ссылками . Мы не замечаем несовершества моделей в режиме болталки, но это критично важно для поисковых систем (напомню, что мы рассматриваем языковые модели в контексте их внедрения в Bing /Google/другие поисковые движки). Как мы уже обсудили, есть два типа данных - факты и языковая информация. В контексте поиска логично разделить их, и научить модель работать с чем-то вроде Базы Данных Фактов . Я вижу к этому два принципиально разных подхода:
Создать отдельное хранилище , с которым модель умеет работать каким-либо образом. Хранилище поддерживает быстрое точечное изменение фактов, их добавление;
Научить модель пользоваться интерфейсами реального мира , подобно человеку. Это может быть браузер, поисковое API, исполнение скриптов, etc.
Дальше в статье сфокусируемся на втором подходе. Отмечу, что первый зародился примерно в 2019м году с выходом статьи kNN-LM , и получил активное развитие от команды DeepMind в лице архитектуры RETRO . Про обе этих статьи у меня есть детальные видео-лекции с разбором : part 1 , part 2 . Про этот подход далее говорить не будем.
Идея предоставить модели доступ в Сеть давно будоражит умы человечества - третий "Терминатор" со Скайнетом вышел 20 лет назад . Главное, что такой подход будет мимикрировать под процесс, который выполняет человек при поиске информации. В идеале для каждого тезиса или вывода, который пишет модель в своем ответе, можно найти и указать референс, источник, в котором модель "подсмотрела" его . Конечно, за скобками остается вопрос надежности источников, тем более в современном то интернете, но сама идея научить нейросеть сёрфить Веб кажется интересной. На новом примере попробуем посмотреть, как это может выглядеть:
Не буду нагонять интригу - демонстрация поиска ответа на вопрос выше выполнена WebGPT, а не человеком . Команда OpenAI разработала подход, который сможет решать задачу long-form question-answering (LFQA) , в которой текст длиной порядка одного-двух параграфов генерируется в ответ на открытый вопрос.
Больше примеров работы модели можно найти по этой ссылке - сайт предоставляет удобный UI для демонстрации процесса поиска ответа.
Но как именно научить языковую модель выполнять поиск ответов на вопрос? Как мы выяснили выше - они всего лишь продолжают написанное, генерируя по токену за раз . Во время процедуры предобучения такие модели видят миллионы текстов, и на основе них учатся определять вероятности появления того или иного слова в контексте. Если же модели вместо обычного человеческого языка показывать, скажем, код на разных языках программирования - для нее задача не изменится. Это все еще предсказание следующего токена - названия переменной, метода, атрибута или класса. На этом принципе основана другая GPT-like модель Codex . Обучение новому языку или новым типам задач (перевод, сокращение текста - суммаризация, выявление логических связей) - всё это достижимо при дообучении модели, если подобранны правильные данные и они " скармливаются " модели в понятном формате (с изображениями такая модель работать не будет - просто не ясно, как их перевести в текст).
Базовый принцип обучения WebGPT с учителем.
А что такое правильные данные в контексте поиска информации в интернете? Это поисковые сессии реальных пользователей, или демонстрации . Важно разработать метод, как последовательность действий будет представляться модели (причем, языковой модели - то есть хочется еще и переиспользовать ее знания об естественном языке), чтобы получился " понятный " формат. Следует начать со списка действий, которые доступны человеку (и модели):
Отправить поисковый запрос в API/строку поиска (авторы используют Bing, и вообще коллаборация OpenAI - Microsoft всё масштабнее и масштабнее ) и получить ответ;
Кликнуть на ссылку в выдаче;
Найти текст на странице;
Прокрутить страницу вверх или вниз;
Вернуться на страницу назад.
Это действия связанны с "браузером", но так как мы решаем задачу генерации ответа на вопрос (именно генерации, а не просто поиска - ведь сам поисковый движок Bing выдаст ответ, но он может быть неполным, неточным), то логично добавить еще два шага: это " цитировать/выписать " (то есть запомнить найденный текст со страницы для себя на будущее) и " сформулировать ответ " - чтобы мы могли понять, что модель закончила работу, и последний написанный текст стоит воспринимать как ответ . Опционально можно ограничивать количество действий, предпринимаемых моделью, что на самом деле важно, ведь для получения очередной команды от модели необходимо ждать существенное количество времени (большие модели размерами в несколько десятков миллиардов параметров тратят на генерацию ответа 0.3-20 секунд , в зависимости от длины текста, размера модели и используемых GPU/ TPU ). Ожидание ответа на вопрос больше минуты явно не способствует улучшению пользовательского опыта.
Команда OpenAI предлагет оригинальное решение перевода пользовательских демонстраций в виртуальный "браузер" для модели , который полностью представлен текстом:
И соответствующий этому cостоянию UI, который видел бы пользователь условного браузера (side-by-side для удобства соотнесения элементов):
Первое изображение представляет собой текстовое описание текущего состояния , которое подается в модель. Та, в свою очередь, должна предсказать следующее действие (из уже приведенного выше списка). Текст, подающийся в модель, состоит из нескольких блоков (отмечены красными цифрами):
Основной вопрос, который задан модели. Он не меняется в течение всей работы над одним ответом;
Блок цитат, которые модель сама себе выписывает . Она сама определяет, с какой части текста по какую цитировать источник. В целом можно сказать, что из этого блока знаний модель и будет генерировать финальный ответ, опираясь на информацию, "отложенную" на будущее в этом блоке. На каждом этапе работы модели видны все цитаты, и LM может понимать, какую информацию сверх этого нужно найти для полного ответа на вопрос, что позволяет писать и отправлять новые запросы в Bing;
Блок последних выполненных в браузере действий, добавленный для консистентности, чтобы модель не повторялась, и не заходила в петлю одних и тех же команд. Важно понимать, что между двумя соседними "прогонами" текста через LM информация никак не сохраняется , и её веса не меняются. Можно сказать, что у модели нет памяти , и именно этот блок помогает отслеживать траекторию ответа на вопрос, чтобы не запутаться;
Заголовок текущей страницы. Тут будет отражен реальный заголовок, если модель "кликнула" на какую-либо ссылку;
Блок текущего окна браузера. Здесь представлено то, что видел бы человек в UI. В конкретном случае предудущее действие  - это запрос в API ("how to train crows to bring you gifts", как видно из блока 3), а значит в блоке 5 представлена часть поисковой выдачи (для примера - 2 ссылки, и их краткие описания). Сейчас модель видит строчки 0-11, и, если будет сгенерирована соответствующая команда, страница прокрутится, и станут доступны новые поисковые результаты;
Вторая ссылка из выдачи поисковика, по сути то же самое, что и блок 5;
Счетчик оставшихся действий (каждый раз уменьшается на единицу) и запрос следующей команды от модели (Next Action) , которая должна быть сгенерирована.
Всё это описано текстом, и подается в текстовую модель как контекст в надежде на то, что в ответ LM сгенериурет следующую команду (вроде "кликни на ссылку один" или "промотай страницу вниз"). Такой контекст называется prompt (промпт). Чем он "качественнее", чем ближе он к тому, что понимают модели (что они видели во время тренировки), тем лучше модель генерирует ответы.
На мой взгляд, важны тут две вещи: то, что модель сама формулирует запросы в браузер, и то, что она умеет выписывать ответы во "внешнюю память" (на листочек :) ). Именно с помощью этих двух механизмов и удается на основе цитат сформулировать полный ответ, подкрепленный фактами и источниками.
Итак, человеческие демонстрации собраны, поисковые сессии переведены в текстовую информацию, и теперь можно дообучить уже существующую языковую модель в классическом режиме предсказания следующего слова , чтобы она скопировала поведение реальных людей при поиске ответов. На этапе тренировки модель каждый раз видит, какой Next Action был выполнен человеком, и учится по промпту (текущему состоянию, с цитатами и поисковой выдачей) это следующее действие угадывать. На этапе предсказания же, как было показано на скриншотах выше (блок 7) промпт в конце содержит фразу "Next Action", а модель в режиме генерации текста уже сама отдает команду . Всего для обучения использовалось 6,209 демонстраций (из интересного - публично доступна инструкция для краудсорсеров; оцените полноту описания задачи и действий. Из своего опыта знаю, что собрать данные от разных людей с разными мнениями бывает очень тяжело, данные друг другу противоречат, и тем важнее максимально подробно донести до исполнителей, что от них требуется). Полученную модель назовем BC-моделью, где BC означает Behavioral Cloning (клонирование поведения), потому что она училась повторять за людьми.
Готова ли наша модель?
Шаг обучения WebGPT для продвинутых: готовим данные.
На самом деле нет :) эти демонстрации лишь показали модели, как взаимодействовать с браузером, что от модели ожидается в качестве команд к действию (Next Action), и как в общем генерировать запросы в Bing API. Финальная цель - сделать модель, которая оптимизирована под качество ответов (измеренное людским мнением), включая, но не ограничиваясь, правдивостью ответа. Тренировка на демонстрациях же не оптимизирует эту метрику каким либо образом. Обратите внимание, это в целом очень частая проблема в машинном обучении - модели обучаются на какую-то прокси-функцию, которая, как мы верим, сильно скоррелированна с метрикой реального мира. Скажем, можно минимизировать квадрат ошибки предсказания продаж в магазине на следующей неделе, но ведь реальная метрика - это деньги, заработанные или полученные компанией. Не всегда удается достигнуть высокой корреляции между этими двумя вещами. Как же обучить модель напрямую оптимизировать предпочтения реальных людей?
В самом слове " предпочтение " есть что-то, что наталкивают на идею сравнений. Оценить какой-то объект в вакууме (абстрактной цифрой от 1 до 10, например, как это часто бывает с фильмами или играми) куда сложнее, чем отранжировать его относительно другого схожего объекта. Само определение подсказывает: "Предпочтение - преимущественное внимание, одобрение, уважение к одному из нескольких вариантов, желание выбрать один из нескольких вариантов ". Тогда, чтобы обучить модель производить ответы, которые наиболее предпочтительны с точки зрения людей, необходимо создать набор пар для сравнения . В контексте ответов на вопросы с помощью поисковой системы это означает, что на один и тот же вопрос предлагается два разных ответа (возможно даже с разным выводом из этих ответов), разные наборы источников, из которых этот ответ собран/сгенерирован.
Такие пары для сравнения (имея обученную на демонстрациях модель) получать очень легко - LMки это алгоритмы вероятностные, как было упомянуто ранее, поэтому можно семплировать действия при генерации команд или ответе на вопрос . Простой пример: модель после получения запроса предсказывает команду "кликни на ссылку 1" с вероятностью 40%, и команду "промотай вниз, к следующему набору ссылок" с вероятностью 37%. Уже на этом этапе доступна развилка в дальнейшей логике поиска информации, и можно запустить эти два процесса в параллель. Таким образом, через сколько-то действий каждая модель придет к ответу, но разными путями . Их мы и предложим сравнить человеку ( финальные ответы и подкрепляющие их источники , не пути).
При оценке каждого из двух ответов используются следующие критерии:
Содержит ли ответ неподкрепленную источниками информацию?.
Предоставлен ли ответ на основной вопрос?
Присутствует ли дополнительная полезная информация, которая не требуется для ответа на вопрос?.
Насколько ответ последователен , и есть ли в нем ошибки цитирования источников/самого себя?
Сколько нерелевантной информации в тексте ответа?
По этим критериям ответы сравниваются, и человек выбирает из 5 обобщённых опций, которые используются в качестве разметки на следующем этапе обучения ( А сильно лучше Б, А лучше Б, А и Б одинаковые, А хуже Б, А сильно хуже Б ). Полная инструкция для исполнителей также доступна . Интересный факт: исполнители не обязаны делать проверку фактов , указанных в источниках, процитированных моделью. Получается, люди оценивают то, насколько хорошо модель умеет опираться на уже предоставленные факты (размещенные на страницах в интернете), без факт-чеккинга.
Авторы подчеркивают, что это проблема для будущих исследований и статей. Я добавлю, что её абсолютно точно необходимо будет решить перед переносом аналога WebGPT в продакшен - например, добавить рейтинги доверия сайтам; указывать, что источник ненадежный; учиться фильтровать источники по агрегированной информации (4 сайта указывают дату, отличную от выбранного источника? тогда этот факт как ненадежный, и не используем в цитировании); наконец, оценка верности факта самой моделью: насколько вероятно, что обычная LM дала бы тот же ответ?
Теперь, когда мы обсудили, как собрать данные предпочтений , чтобы "выровнять" нашу модель относительно намерений пользователей во время поиска информации, поговорим про принцип обучения. Проблема с предпочтениями и сравнениями в том, что процесс разметки таких данных занимает много времени . Нужно погрузиться в каждый вопрос, ответ, проанализировать источники, выставить оценки. Получение большого количества данных либо займет много времени, либо будет стоить огромных денег. Но что если нам не нужно размечать каждую пару? Что если мы, как инженеры машинного обучения, научим другую модель сравнивать пары ответов за людей?
Шаг обучения WebGPT для продвинутых: учим модель учить модель.
В предшествующих исследованиях OpenAI было эмпирически выяснено, что модели в целом хорошо предсказывают реакции людей и их оценки в задачах, связанных с генерацией комплексных ответов. Вырисовывается следующая схема, которая является ключевой для обучения по обратной связи от людей (human feedback):
Генерируем набор пар для сравнения , используя модель, обученную на демонстрациях (она уже умеет "серфить" интернет, писать запросы и "кликать" по ссылкам, то есть выдавать соответствующие команды в виде текста);
Размечаем пары с использованием людей;
Тренируем другую модель предсказывать разметку людей (какой ответ из пары получит более высокий ответ) на парах из п.2. Назовем такую модель Reward Model (RM) . Она принимает на вход вопрос и финальный сгенерированный ответ (без промежуточных шагов вроде прокрутки браузера), а выдаёт одно вещественное число (оно еще называется наградой, или Reward - по историческим причинам). Чем больше это число - тем выше вероятность того, что человек высоко оценит этот ответ по сравнению с остальными. Можно считать, что это условный ELO-рейтинг , как в шахматах;
Обучаем основную модель (BC) на основе оценок от модели из п. 3; По сути LM учится решать задачу " как мне поменять свой сгенерированный ответ так, чтобы получить большую оценку RM? ";
Повторяем пункты 1-4 итеративно.
Этот пайплайн имеет две ключевые особенности. Во-первых, его можно повторять итеративно, улучшая именно текущую модель , со всеми ее минусами и плюсами. Если LM в какой-то момент начала обманывать, или использовать несуществующие факты (дефект обучения) - это будет заметно на разметке людьми, и соответствующие ответы получат низкие оценки. В будущем модели будет невыгодно повторять подобное (возникнет negative feedback). А во-вторых, и это просто прекрасно - используя RM из пункта 3, мы можем сгенерировать оценки для куда большего количества пар (и гораздо быстрее), чем если бы это делали люди. Следите за руками: берем любые доступные вопросы из интернета, из датасетов или даже специально заготовленные, на которых модель еще не обучалась, генерируем ответы, оцениваем их автоматически, без привлечения людей , и уже на основе этих оценок дообучаем основную WebGPT. Если люди могут за, скажем 10,000$ разметить 5,000 пар за неделю, то 1 землекоп RM может за день отранжировать десятки и сотни тысяч пар ответов фактически за копейки.
Важное замечение по Reward Model для графиков ниже по статье: часто по оси OY будет Reward Value (оно же RM Score). Для удобства сравнения, во всех случаях предсказания RM были стандартизированы , то есть из предсказанного значения вычитали среднее по всем генерациям (поэтому среднее значение теперь равно нулю; и больше нуля - значит лучше среднего ), и полученную разность делили на стандартное отклонение (поэтому в большинстве случаев Reward находится в интервале [-1; 1]). Однако основная логика сохраняется - чем больше значение, тем лучше оценен ответ.
В такой постановке задачи оптимизации очень легко переобучить модель под конкретную Reward Model , а не под оценки разметчиков, под общую логику. Если это произойдет, то LM начнет эксплуатировать несовершества RM - а они обязательно будут, как минимум потому, что количество данных, на которых она тренируется, очень мало (суммарно на всех итерациях оценено порядка 21,500 пар, но для тренировки доступно 16,000), и её оценка не в точности повторяет оценки людей. Можно представить случай, что RM в среднем дает более высокую оценку ответам, в которых встречается какое-то конкретное слово . Тогда WebGPT, чрезмерно оптимизирующая оценку RM (вместо людской оценки, как прокси-метрику), начнет по поводу и без вставлять такое слово в свои ответы. Подобное поведение продемонстрировано в другой, более ранней статье OpenAI , с первыми попытками обучения моделей по обратной связи от людей:
Поэтому очень важно подойти основательно к процессу итеративного обучения двух моделей.
Интересный факт про RL-подход: для улучшения сходимости, а также уменьшения количества необходимых данных при общей процедуре обучения, авторы раз в несколько шагов добавляли 15 эпизодов генерации финального текстового ответа по уже набранным источникам информации . Это позволяет писать более связные и консистентные ответы, и наилучшим образом (с точки зрения Reward Model, то есть почти человеческой оценки) использовать источники и текст из них.
Регуляризация при обучении WebGPT.
Регуляризация - краеугольный камень машинного обучения. Обычно это работает так: добавляешь в большую математическую формулу для оптимизации еще пару членов, которые, как кажется на первый взгляд, взяты на ходу из головы - и модель начинает учиться лучше, учиться стабильнее, или просто хотя бы начинает учиться . В целом регуляризация направлена на предотвращение переобучения , и часто зависит от способа тренировки и самой архитектуры модели.
Так как мы переживаем, что модель начнет эксплуатировать неидеальность Reward Model, и это выльется в бессмысленные или некорректные генерации, то стоит задуматься над добавлением штрафа за, собственно, бессмыслицу. Но как её оценить? Существует ли инструмент, который позвоялет определить общую адекватность и связанность текста?
Нам очень повезло: мы работаем с языковыми моделями, натренированными на терабайтах текста, и они хороши в оценке правдоподобности предложений (вероятности из появления в естественной среде, в речи или скорее в интернете. Можно рассчитать как произведение вероятностей каждого отдельного токена). Особенно остро это проявляется в случаях, когда одно и то же слово повторяется по многу раз подряд - ведь в языке такое встретишь нечасто . Получается, что при обучении модели мы можем добавить штраф за генерацию неестественного текста . Для того, чтобы модель не сильно отклонялась от уже выученных текстовых зависимостей, введем член регуляризации, отвечающий за разницу между распределениями вероятностей слов, предсказанными новой обучаемой моделью и оригинальной BC (после тренировки на демонстрациях).
Чаще всего для этой цели используется Дивергенция Кульбака-Лейблера : это нессиметричная неотрицательная мера удаленности двух вероятностных распределений . Чем более похожи распределения, тем меньше её значение, и наоборот. Это значение вычитается из общей награды, и - так как мы решаем задачу максимизации - мешает достижению цели. Таким образом, мы вынуждаем модель найти баланс между отступлением от исходной BC с точки зрения генерируемых вероятностей для текста и общей наградой за генерацию. Приведённый подход - не панацея, и он не позволит бесконечно тренировать модель относительно зафиксированной RM, однако может продлить процесс, увеличивая тем самым эффективность использования разметки.
Альтернатива RL: меняем шило на мыло.
Обучение с применением RL - задача не из лёгких, тем более на такой необычной проблеме, как " оптимизация генерируемого текста согласно фидбеку людей ". Пользуясь тем, что WebGPT представляет собой языковую модель, оперирующую вероятностями, из которых можно семплить, авторы предлагают альтернативный способ, который не требует дообучения модели (относительно BC, после использования датасета демонстраций), однако потребляет куда больше вычислительных ресурсов.
Этот метод называется Best-of-N , или Rejection Sampling , и он до смешного прост. После полученя первой группы размеченных пар сравнений ответов WebGPT, согласно плану пайплана, обучается Reward Model. Эта модель может выступать в качестве ранжировщика для десятка (или N, если быть точным. Best-of-64 означает ранжирование 64 вариантов) потенциальных ответов одновременно, ее задача - проставление оценки (согласно предсказанию) и упорядочивание всех ответов. Самый высокооценённый ответ из всех и является финальным.
Разные ответы получаются за счет разных действий, сгенерированных WebGPT - на самом раннем этапе это может быть слегка изменённая формулировка вопроса в Bing API; чуть позже - прокрутка на 3-4 страницу поисковой выдачи вместо проверки топа; под конец - финальные формулировки, используемые для связывания процитированных фактов. Развилок достаточно много (во время генерации каждой команды! А ведь их может быть и 100), и потому варианты получаются действительно неоднородными . Более того, у модели появляется шанс "прокликать" как можно больше ссылок (в разных сессиях, но при ответе на один и тот же вопрос - то есть паралелльно). Быть может, лучший ответ на поступивший запрос спрятан в сайте с невзрачным описанием, которое видит модель в поисковой выдаче, однако внутри предоставлен наиболее точный ответ - в таком случае обилие посещённых сайтов играет лишь на руку. А главное - никакого обучения, как только получена версия Reward Model. Для генерации используется LM, обученная только на демонстрациях (BC, порядка 6,200 примеров - очень мало по меркам Deep Learning /современного NLP).
А сколько разнообразных ответов оптимально генерировать для ранжирования, и что вообще такое " оптимально "? Ответы на эти вопросы представлены на картинке слева. Чем больше модель, тем больше генераций можно пробовать ранжировать , и тем больший прирост к метрике это даст. В целом, это логично - большие модели хранят больше знаний, их выдача более разнообразна, а значит может привести к таким сайтам и, как следствие, ответам, которые не встречаются у других моделей. Оптимальными считаются точки перегиба на графике, где прирост метрики за счет наращивания ресурсов начинает уменьшаться . Это значит, что можно взять модель чуть-чуть побольше, натренировать ее и получить метрику немного выше. Однако видно, что даже маленькая модель на 760M параметров может тягаться с 175B гигантом - просто нужно генерировать порядка сотни вариантов (и это всё еще будет на порядок вычислительно эффективнее 2-3 вариантов от LLM GPT-3). Отмеченные на графике звёздочками точки являются оптимальными для рассматриваемых моделей, и именно эти значения будут использовать для рассчета метрик ниже (например, N=16 для средней модели на 13B параметров).
Метрики и восприятие людьми.
Начнем с конца - попробуем оценить, какой из методов генерации ответов показывает себя лучше: RL (обучение через моделирование функции оценки ответа) или BoN (без дообучения; множественное семплирование из модели). Может ли их комбинация прирастить качество генерируемых ответов еще сущестеннее?
Попробуем разобраться, как производить такое сравнение. У нас есть модель, обученная исключительно на 6,200 демонстрациях, без прочих трюков, и в режиме языкового моделирования. Напомню, что её называют BC (Behavioral Cloning). Относительно ответов, порождаемых этой моделью, можно проводить сравнения по уже описанному выше принципу с ответами от других моделей. Если качество ответов в среднем одинаковое, то можно ожидать ситуации  50/50 - когда в половине случаев люди предпочтут ответ первой модели, а в половине - второй. Если ответы одной модели стабильно выигрывают в 55% случаев - можно сказать, что - согласно оценке людей - её ответы качественнее.
Именно поэтому величина в 50% отмечена пунктирной линией на графике - это наша отправная точка, и мы хотим видеть прирост доли выигранных сравнений относительно заданного уровня. Из графика можно сделать несколько выводов. Во-первых, RL позволяет улучшить модель, натренированную на демонстрациях (то есть все эти трюки с RM и разметкой были не зря!). Во-вторых, самый лучший результат - 58% побед для 175B Bo1 модели . В-третьих, RL и Rejection Sampling плохо сочетаются , и либо ухудшают результат, либо не меняют его существенно (исключение 13B-Bo16 модель, однако это скорее выброс, случившийся из-за маленького размера выборки для оценки).
Если же сравнить отдельно BoN модель (генерация N ответов BC-моделью и ранжирование через оценку RM) с самой BC моделью (то есть параметры сетей одинаковые, отличается только способ получения ответа, и как следствие вычислительная мощность, необходимая для генерации), то процент побед будет равняться 68% (при N=64, что, согласно приведенной оценке выше в статье, является оптимальным значением). Получается, что одной и той же BC модели Bo64 проигрывает в 32% случаев, а RL - в 42%. Разница существенна, если учесть, что м етрика рассчитана на реальных человеческих оценках , восприятии. По этой причине дальше авторы статьи большинство экспериментов делают именно с BoN-моделями, а не RL. Но вообще интересно разобраться, почему так может происходить, что дообученная модель хуже показывает себя, чем модель, видевшая лишь 6,200 демонстраций . Можно выдвинуть несколько гипотез или связать это со следующими фактами:
Исходя из специфики задачи, может быть существенно выгоднее посетить бОльшее количество сайтов , сделать больше попыток запросов в API, чтобы сгенерировать качественный ответ;
Среда, в которую "играет" наша модель (интернет и вебсайты, поисковый движок), безумно сложна для прогнозирования. В то же время с применением Rejection Sampling модель может попытаться посетить гораздо больше веб-сайтов, и затем оценить полученную информацию через RM;
RM была натренирована в основном на сравнениях, сгенерированных BC и BoN-моделями, что ведет к смещению в данных. Быть может, если собирать датасет сравнений исключительно под PPO-алгоритм, то проигравший и победитель поменяются местами;
В конце концов, как было упомянуто выше, RL-алгоритмы требуют настройки гиперпараметров , и хоть PPO в достаточной мере нечувствивтелен к их выбору, всё равно нельзя утверждать, что полученная в результате обучения модель оптимальна, и ее нельзя существенно улучшить;
Вполне возможно, что в результате неоптимального выбора параметров в пункте 4 произошло переобучение под RM, и модель потеряла обобщающую способность . Как следствие - получает более низкие оценки ответов от людей;
Стоит дополнительно отметить, что немало усилий было приложено и к обучению исходной BC модели. Авторы долго и тщательно подбирали гиперпараметры, и в итоге это привело к существенному сокращению разрыва в метриках , который изначально наблюдался между BC и RL подходами. Таким образом, сам по себе бейзлайн в виде BC достаточно сильный, производящий осмысленные и высокооцененные ответы.
Следующим логичным шагом становится сравнение лучшей модели (175B Bo64) с ответами, написанными самими живыми людьми. Это не упоминалось ранее, однако исходные вопросы для сбора демонстраций и генерации пар на сравнение (в RL/RM частях) были выбраны из датасета ELI5 . Он сформирован следующим образом: на Reddit есть сабреддит Explian me Like I'm Five (ELI5), где люди задают вопросы, и в комментариях получают ответы . Для сбора демонстраций при тренировке BC разметчики сами искали ответы на вопрос, прикрепляли источники информации/ссылки (как было описано далеко в начале статьи). Однако в самом датасете ответами считаются самые высокооцененные (залайканные) комментарии , с некоторыми фильтрациями и ограничениями. И формат таких ответов существенно отличается от производимого моделью: там (зачастую) нет ссылок-источников, упоминаемые факты не сопровождаются аннотацией ( [1][2] для указания на первый и второй источник, к примеру).
Указанные особенности подводят нас к развилке:
С одной стороны, мы можем сравнить результаты модели на новых вопросах, демонстрации для которых не участвовали в тренировочной выборке, и для которых есть аннотированные ответы с указанием источников. Такие ответы с нуля написаны живым человеком по результатам его поиска;
С другой, если на этапе постобработки вырезать блок ссылок из ответа модели, а также их упоминания-референсы в тексте, то такие ответы, в теории, можно сравнить с исходными комментариями людей на Reddit..
Поэтому проведём два сравнения! Однако стоит учесть, что люди, участвовавшие в генерации демонстраций или же в сравнении двух ответов по разным факторам (влкючающим корректность цитирования источника), имеют некоторую смещенную точку зрения на задачу : они уже видели инструкцию по разметке, представляют примерный процесс ответа на вопрос, знакомы с критериями оценки. Их мнение в слегка измененной задаче нельзя назвать незамыленным . Исходя из этого, для человеческой оценки качества оригинальных ответов на Reddit против ответов модели были наняты новые разметчики, которым было сообщено куда меньше деталей о проекте (инструкция занимает буквально пару страниц). Они практически идеально представляют собой усредненное мнение человека , который просто хочет получить вразумительный ответ на свой вопрос.
Оценивалось всего три показателя - общая полезность ответа, согласованность и фактическая точность. На графике слева видно, что большая модель 175B Bo64 генерирует ответы, которые в 56% случаев признаны более полезными, чем ответы, полученные ручным поиском живого человека с последующей ручной компиляцией ответа по источникам . Немного страдает согласованность, а фактическая аккуратность держится на уровне. Можно сказать, что таким сгенерированным ответам стоит доверять, как если бы вы сами искали ответ на вопрос в интернете (не то что ответы ChatGPT или Galactica!). Главный вывод тут - модель выигрывает у написанных людьми ответов в более чем 50% случаев - то есть достигает уровня человека в использовании браузера для поиска информации . Также стоит отметить, что использование обратной связи от людей (пары сравнений для обучения Reward Model) имеет важнейшее значение, поскольку нельзя ожидать превышения планки 50% предпочтений только за счет подражания исходным демонстрациям (в лучшем случае мы научимся делать точно так же, и получится 50/50).
На графике справа, иллюстрирующем сравнение относительно оригинальных ответов из комментариев на Reddit, метрики еще лучше ( ответ модели выбирается лучшим из пары 69% случаев ). В целом, это не удивительно - люди пишут ответы в свободное время, ничего за это не получая (кроме апвоутов и кармы), и иногда ссылаются на знания из памяти, и не проверяют факты в интернете.
Заключение.
Да, полученная модель не гарантирует выверенных и 100% фактологически точных ответов на запросы, однако это гораздо сильнее приближает описанный подход (и ChatGPT вместе с ним) к надежным поисковым системам, которые можно не перепроверять на каждом шагу . Более того, такие модели уже сейчас способны сами добровольно предоставлять источники информации, на которые опираются - а там дело за вами. Для самых терпиливых читателей, добравшихся до заключения, у меня подарок - три сайта, в которых реализованы поисковики на принципах обучения моделей, описываемые в статье:
https://phind.com/.
https://you.com/.
https://www.perplexity.ai/.
Уже сейчас они предоставляют возможность получать ответ в режиме диалога, и это только начало. У меня очень большие ожидания от 2023го года, и надеюсь, что у вас теперь тоже!
P.S.: разумеется, от метода, разобранного в статье, до готового к внедрению в продакшен решения необходимо преодолеть огромное количество других проблем и инженерных задач. Я выбрал данную тему исходя из ситуации, которую наблюдаю в разнообразных телеграм, слак и прочих чатах: люди массово жалуются и упрекают ChatGPT в том, что она врет, подтасовывает факты . "Как это внедрять в поиск? Оно же даже дату развала СССР не знает!!!". В этом массовому потребителю и видится основная проблема. Надеюсь, что сейчас стало более понятно, как близки мы к новой парадигме обращения с поисковыми системами.
Об авторе.
Статья подготовлена и написана Котенковым Игорем ( @stalkermustang ). Буду рад ответить на вопросы из комментариев и добавить обучающие заметки в текст материала по запросу.
Подписывайтесь на авторский телеграм-канал, где вас ждёт ещё больше новостей, разборов и объяснений из мира NLP, ML и не только! Кроме того, в чате канала можно обсудить идеи из статьи с другими участниками сообщества.
